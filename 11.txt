Глобальные сборки
Преиммущества GAC - использование сборки несколькими приложениями, защищает от копирования и изменения, 
всегда легче развернуть новую сборку через GAC для всех приложений.
Ключ состоит из открытыго ключа, закрытого ключа, версии сборки, имени без расширения и cultureinfo. 
Хранятся всегда хэш маркеры, чтобы экономить место.
AssemblyRef содержит данные маркеры, чтобы найти все файлы сборок, на которые проект ссылается.
Можно встраиватьв GAC данные без закрытого ключа (отложенное подписание), но тогда оно не будет проверять 
данные на целостность.

Как происходит запуск приложения на .net
Грузится CLR -> поиск точки входа в приложение -> IL-код -> код преобразуется в ассемблер


new -> подсчитываем необходимое кол-во памяти -> даём адрес путём прибавления необходимого кол-ва к сущ. -> получаем ссылку, если хватает памяти. Если не хватает, то выполняется Garbage Collector

Значимые типы всегда сохраняются в стеке потока в именованной области с именем переменной.

GC.
Работает с управляемой кучей.
1. Приостанавливает процессы и потоки.
2. Маркировка. 
2.1. Помечает абсолютно всё на удаление первым значимым битом со значением 0.
2.2. Рекурсивно проверяет все корни (ссылки) на ссылки на объекты, если нулл - не трогает, иначе помечает 1. 
Также проверяет ссылки уже помеченных битов т.е. ссылка на ссылку тоже помечается, как 1.
2.3. Удаляет все значения с 0.
3. Сжатие.
3.1. Перемещает вниз все маркированные 1 объекты, чтобы занять один блок памяти.
3.2. Даёт адреса на новую область памяти.
4. Возобновляем потоки и процессы словно уборки и не было.
Если вдруг памяти не хватило, то возникает исключение OutOfMemory.
Утечки памяти как правило из-за статической ссылки, которая после очистки сохраняет все эллементы коллекции.
При вызове GC.Collect(); необходимо помечать объект явно методом Dispose(); т.к. иначе GC.Collect его почистит к чертям собачьим.
GGC - Generational GC.
Делит кучу на поколения. Первое всегда поколение 0. 
Если мусор чистился для поколения 0, то оно становится поколением 1 и так далее. Поддерживает только 0,1,2 поколения.
Чем ниже ранг поколения, тем больше вероятность того, что оно его почистит. Первым всегда чистится поколение 0.
Дальше происходит очистка поколения 1 и так далее, пока памяти не хватит.
Очистка на поколение выше переходит только в том случае, если занимаемое место превышает пороговое значение, которое выделил GC.
GC сам определяет пороговые значения.
Если он видит, что посли очистки остаётся мало занимаемого места в поколении, то GC уменьшает пороговое значение.
Если остаётся много объектов, то может увеличить порог для поколения.
Большие объекты всегда помещаются в память в поколение 2 и для них не происходит сжатие.
Есть два режима работы GC. 
Обычно запускается режим рабочей станции, который не забирает огромные ресурсы на очистку памяти
Режим сервера забирает много ресурсов на очистку памяти с использованием распаралеливания поколений или задач.
Программно можно вызвать путём GC.Collect(). GC.CollecionMode - настраиваемое значение уборщика мусора. 
GC.CollectionCount(Номер поколения) - кол-во операций для очистки в конкретном поколении.
Финализаторы (~) срабатывают в момент\до очистки мусора.


Неявный DownCast можно, upcast - нельзя.

is проверяет типы на совместимость
as выполняет приведение типов и возвращает ссылку на память, либо null. Не генерирует исключение.
using всего лишь добавляет имя типа. Не эффективно, когда юзингов куча.

FCL (Framework Class Library) int - Int32, нет разницы между string и String.
CIL (IL) - Common Intermidiate Language - промежуточный язык, который выполняет некоторые операции до передачи к ассемблеру.
Значимые типы (типы значения) в стеке потока, ссылочные в куче. 
Стек потока - размеченная область памяти приложения. 1 мб по стандарту, состоит из страниц, последняя страница всегда запасная и как только используется - генерится исключение о том, что стековерфлоу. При попытке выйти за пределы стека система просто вырубает процесс и всё.


В целом по веб
HTTP запросы состоят из:
1. Request line - строка запроса, указывает версию HTTP, URL и метод передачи.
2. Заголовки - передают некоторую информацию о сообщении (использовать ли кукисы, какой браузер, разрешённые языки, форматы)
3. Сообщение - данные и их описание.

HTTPS от HTTP отличается:
1. HTTP - 80 порт, HTTPS - 443.
2. HTTPS поддерживает TLS (Transport Layer Security) и SSL (Secure Socket Layer) шифрование.

HTTPS работает так:
Устанавливаем соединение -> получаем открытый ключ - генерируем число - шифруем открытым ключом - отправляем на сервер, где он расшифровывает его закрытым ключом.
Сертификат - информация о времени действия сертификата, имя сервера, клиента и т.п.
Кукисы - временные файлы, которые живут по надобности (Можно чистить, можно ставить автоматическое удаление).


В целом по SQL
Группировка, функции, процедуры, запросы.

Наследование:
Исключения
EF
JS
HTML и CSS